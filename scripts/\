#!/usr/bin/env python3


import analysis_pqc as fp
import pqc_analysis_tools as tools
import pqc_analysis_json as pqc
import os
import sys
import argparse
import pandas as pd
import yaml
import math



def df_to_csv(df, flute):

    df.to_csv('/mnt/c/Users/Kostas/Desktop/{}.csv'.format(flute), mode='a', index=False)



def read_config():
    
    with open('PQC_specs.yml', 'r') as f:
         conf = yaml.load(f, Loader=yaml.FullLoader)
    
    
    return conf



def append_dictionary(current_dict, dict_to_append, flute, test):
    
    conf = read_config()
    
    for key, values in dict_to_append.items():
        if key in current_dict.keys():
              if not math.isnan(float(values)) and abs(values-conf[flute][test]) < abs(current_dict[key]-conf[flute][test]):
                   current_dict.update({'{}'.format(key): values})
                
              else:
                  pass
        else:
            current_dict.update({'{}'.format(key): values})

    return current_dict  


            


class Flute1:

    
    def __init__(self, path, label):
        
        self.path = path
        self.label = label
        self.flute = 'Flute 1'
        
        self.functions = {'mos': self.mos,
              'fet': self.fet,
              'van-der-pauw': self.vdp,
              'capacitor': self.capacitor}
    

 



    def mos(self, fil, lex):

       try:
           v_fb1, v_fb2, t_ox, n_ox, Q_ox, c_acc = pqc.analyse_mos_data(fil, False)
        
           #c_acc, _ = pqc.normalise_parameter(c_acc, 'C')
           #n_ox, _ = pqc.normalise_parameter(n_ox, 'cm-2')
           #print(c_acc)

       except Exception as err:
           v_fb2, c_acc, n_ox = "NaN"

       fg = ({'Vfb [V]': v_fb2,
              'Cacc [pF]': c_acc,
              'n_ox [cm^-2]': n_ox})

       append_dictionary(lex, fg, self.flute, 'mos_vfb')
       
       return lex




    def fet(self, fil, lex):

       try:
           v_th = pqc.analyse_fet_data(fil, False)
       except:
           v_th = "NaN" 
    
    
       fg = ({'V_th [V]' : v_th})
  
       lex = append_dictionary(lex, fg, self.flute, 'fet_vth')
    
       return lex




    def vdp(self, fil, lex, linewidth=False):
 
       try:
           r_sheet, lbl = pqc.analyse_van_der_pauw_data(fil, False)
           #r_sheet, _ = pqc.normalise_parameter(r_sheet, 'Ohm')   

       except Exception as err:
           r_sheet = "NaN"

       if "N" in fil:
           test = 'N_vdp'
           if "Reverse" in fil:
              fg = ({'VdP-N (r) [Ohm\sq]': r_sheet})
           else:
              fg = ({'VdP-N (s) [Ohm\sq]': r_sheet})    
   
       elif "P-stop" in fil:
              test = 'P-stop_vdp'
              if "Reverse" in fil:
                   fg = ({'VdP-Pstop (r) [kOhm\sq]' : r_sheet})
              else:
                   fg = ({'VdP-Pstop (s) [kOhm\sq]' : r_sheet}) 
   
       else:
             test = 'Rpoly_vdp'
             if "Reverse" in fil:
                  fg = ({'VdP-Rpoly (r) [kOhm\sq]' : r_sheet}) 
             else:
                  fg = ({'VdP-Rpoly (s) [kOhm\sq]' : r_sheet}) 

       
       lex = append_dictionary(lex, fg, self.flute, test) 
    
       if linewidth:
       
             return r_sheet
       else:
             return lex




    def capacitor(self, fil, lex):

    
       try:  
           c_mean, c_median = pqc.analyse_capacitor_data(fil, False)

           #c_median, _ = pqc.normalise_parameter(c_median, 'C')

       except Exception as err:
           c_median = "NaN"


       if "_Left_" in fil:
             fg = ({'CapW [pF]' : c_median})
       else:
             fg = ({'CapE [pF]' : c_median}) 

       lex = append_dictionary(lex, fg, self.flute, 'cap') 


       return lex

    
   
   
   
    def run(self):

      
      lex = {'Halfmoon': self.label} 
      for  key, f in self.functions.items():

        directory = tools.find_all_files_from_path(self.path, '{}'.format(key))
        for i in directory:
           if 'Flute_1' in i and 'eft' in i:
               lex = f(i, lex)
    
      if os.path.isfile('/mnt/c/Users/Kostas/Desktop/{}.csv'.format(self.flute)):
           df = pd.DataFrame(data=lex, columns = lex.values(), index=[0])
      else:
           df = pd.DataFrame(data=lex, columns = lex.keys(), index=[0])
    
      df_to_csv(df, self.flute)
      lex.clear()





#####################################################################################################################


class Flute2:
    
    def __init__(self, path, label):
        
        self.path = path
        self.label = label
        self.flute = 'Flute 2'
        
        self.functions = {'gcd': self.gcd,
              'linewidth': self.linewidth,
              'breakdown': self.breakdown}
    
    
        
    def gcd(self, datafile, data_dict):
      
        try:
            i_surf, i_bulk, vfb_acc, vfb_inv, s0 = pqc.analyse_gcd_data(datafile, False)
        except Exception as err:
            i_surf, i_bulk, vfb_acc, vfb_inv, s0 = 'NaN'

        par_dict = ({'I_surf [pA]': i_surf,
              'S_0 [cm/s] ':  s0,
              'Vth_acc [V]': vfb_acc,
              'Vth_inv [V]': vfb_inv})

        data_dict = append_dictionary(data_dict, par_dict, self.flute, 'gcd_vfb')
       
        return data_dict


    
  
   
    def linewidth(self, datafile, data_dict):
       

        try:
            vdp_list = tools.find_all_files_from_path(self.path, 'van-der-pauw') 
            
            if "_N_" in datafile:
                for i in vdp_list:
                  if 'N' in i and 'Reverse' not in i: 
                    print(type(i))

                    r_sheet = Flute1.vdp(self, i, data_dict, True)
                    print('Rsheet is {}'.format(r_sheet))
                    t_line = pqc.analyse_linewidth_data(datafile, r_sheet, False)
                    test = 'N_linewidth'
                    par_dict = ({'N-line [um]': t_line})    
   
            elif "P-stop" and "2-wire" in datafile:
                for i in vdp_list:
                  if 'P-stop' in i and 'Reverse' not in i:
                    r_sheet = Flute1.vdp(self, i, data_dict, True)
                    t_line = pqc.analyse_linewidth_data(datafile, r_sheet, False)
                    test = 'P-stop linewidth'
                    par_dict = ({'Pstop-line [um]' : t_line})
            
            
            data_dict = append_dictionary(data_dict, par_dict, self.flute, test)
 

        except Exception as err:
            t_line = 'Nan'
            
        #print(datafile)
        
          
        return data_dict


    
    def breakdown(self, datafile, data_dict):

        try:
            v_bd = pqc.analyse_breakdown_data(datafile, False)
        except Exception as err:
            v_bd = 'NaN'

        par_dict = ({'V_bd [V]' : v_bd})

        data_dict = append_dictionary(data_dict, par_dict, self.flute, 'breakdown')

        return data_dict




    def run(self):

      
      data_dict = {'Halfmoon': self.label} 

      for  key, f in self.functions.items():

        directory = tools.find_all_files_from_path(self.path, '{}'.format(key))
        for i in directory:
           if 'Flute_2' in i and 'eft' in i:
               
               data_dict = f(i, data_dict)
    
      if os.path.isfile('/mnt/c/Users/Kostas/Desktop/{}.csv'.format(self.flute)):
           df = pd.DataFrame(data=data_dict, columns = data_dict.values(), index=[0])
      else:
           df = pd.DataFrame(data=data_dict, columns = data_dict.keys(), index=[0])
    
      df_to_csv(df, self.flute)




#####################################################################################################################

class Flute3:    


 def __init__(self, path, label):
        
        self.path = path
        self.label = label
        self.flute = 'Flute 3'
        
        self.functions = {'bulk': self.bulk_cross,
              'clover': self.clover_metal,  
              'meander': self.metal_meander,
              'van-der-pauw': self.pPlus_vdp,
              'linewidth': self.pPlus_linewidth,
              'cv': self.cv,
              'iv': self.iv}
    


 def bulk_cross(self, datafile, data_dict):

      try: 
          r_sheet, _ = pqc.analyse_cross_data(datafile)
      except:
          r_sheet = 'NaN'
      
      if 'Reverse' in datafile:
            par_dict = ({'vdP_Bulk (r) [kOhm/sq]': r_sheet})
      else:
            par_dict = ({'vdP_Bulk (s) [kOhm/sq]': r_sheet})

      data_dict = append_dictionary(data_dict, par_dict, self.flute, 'bulk_cross')

      return data_dict




 def clover_metal(self, datafile, data_dict):

      try: 
          rho_sq = pqc.analyse_meander_data(datafile)
      except:
          rho_sq = 'NaN'
      
      if 'Reverse' in datafile:
             par_dict = ({'CloverMetal (r) [mOhm/sq]': rho_sq})
      else: 
             par_dict = ({'CloverMetal (s) [mOhm/sq]': rho_sq})
  
      data_dict = append_dictionary(data_dict, par_dict, self.flute, 'clover_metal')

      return data_dict

 
 
 def metal_meander(self, datafile, data_dict):

        try:
            rho_sq = pqc.analyse_meander_data(datafile, False)
        except:
            rho_sq = 'NaN'

        par_dict = ({'R_meander [Ohm]': rho_sq})

        data_dict = append_dictionary(data_dict, par_dict, self.flute, 'metal_meander')

        return data_dict

 
  
  
 def pPlus_vdp(self, datafile, data_dict, line = False):

   if 'P_cross' in datafile:
    
      try: 
          r_sheet, _ = pqc.analyse_van_der_pauw_data(datafile, False)
      except:
          r_sheet = 'NaN'
     
      print("Rsheet") 
      if 'Reverse' in datafile:
            par_dict = ({'pPlus_vdp (r) [kOhm/sq]': r_sheet})
      else:
            par_dict = ({'pPlus_vdp (s) [kOhm/sq]': r_sheet})

    
      if line:
          print("Yes it is")
          return r_sheet
      else:
          data_dict = append_dictionary(data_dict, par_dict, self.flute, 'pPlus_vdp')
          return data_dict
   
   else:
        return data_dict


 def pPlus_linewidth(self, datafile, data_dict):

    try:
         vdp_list = tools.find_all_files_from_path(self.path, 'van-der-pauw') 
         for i in vdp_list:
             if 'P_cross' in i: 
                print("Pcrosssss") 
                r_sheet = self.pPlus_vdp(i, data_dict, line=True) 
                print('Rsheet for line is {}'.format(r_sheet))
                t_line = pqc.analyse_linewidth_data(datafile, r_sheet, False)
      
    except Exception as err:
                 t_line = 'NaN'
    
    par_dict = ({'Linewidth pPlus [um]': t_line})

    data_dict = append_dictionary(data_dict, par_dict, self.flute, 'pPlus_linewidth')

    return data_dict
    
       




 def cv(self, datafile, data_dict):

      try: 
          vfd = pqc.analyse_cv_data(datafile, False)
      except Exception as err:
          vfd = 'NaN'

      par_dict = ({' V_fd [V]': vfd})

      data_dict = append_dictionary(data_dict, par_dict, self.flute, 'cv')

      return data_dict


 def iv(self, datafile, data_dict):

      try: 
          i600, _ = pqc.analyse_iv_data(datafile, False)
      except Exception as err:
          i600 = 'NaN'

      par_dict = ({' I600 [A]': i600})

      data_dict = append_dictionary(data_dict, par_dict, self.flute, 'iv')

      return data_dict





 def run(self):

      
      data_dict = {'Halfmoon': self.label} 

      for  key, f in self.functions.items():
 
        directory = tools.find_all_files_from_path(self.path, '{}'.format(key))
        for i in directory:
           if 'Flute_3' in i: 
              data_dict = f(i, data_dict)
      if os.path.isfile('/mnt/c/Users/Kostas/Desktop/{}.csv'.format(self.flute)):
           df = pd.DataFrame(data=data_dict, columns = data_dict.values(), index=[0])
      else:
           df = pd.DataFrame(data=data_dict, columns = data_dict.keys(), index=[0])
    
      df_to_csv(df, self.flute)









#####################################################################################################################
class Flute4:


 def __init__(self, path, label):
        
        self.path = path
        self.label = label
        self.flute = 'Flute 4'
        
        self.functions = {'gcd05': self.gcd,
              'cbkr': self.cbkr,  
              'contact': self.contact,
              }
 

 

 def gcd(self, datafile, data_dict):
      
        try:
            i_surf, i_bulk, vfb_acc, vfb_inv, s0 = pqc.analyse_gcd_data(datafile, False)
        except Exception as err:
            i_surf, i_bulk, vfb_acc, vfb_inv, s0 = 'NaN'

        par_dict = ({'I_surf [pA]': i_surf,
              'S_0 [cm/s] ': s0,
              'Vfb_acc [V]': vfb_acc,
              'Vfb_inv [V]': vfb_inv})

        data_dict = append_dictionary(data_dict, par_dict, self.flute, 'gcd_vfb')
       
        return data_dict




 def cbkr(self, datafile, data_dict):

        try:
            r = pqc.analyse_cbkr_data(datafile, False)

        except Exception as err:
            r = 'NaN'

        if 'N' in datafile:
            par_dict = ({'CBKR_strip [Ohm/sq]' : r })
        else:
            par_dict = ({ 'CBKR_poly [kOhm/sq]' : r})

        data_dict = append_dictionary(data_dict, par_dict, self.flute, 'cbkr')

        return data_dict


 def contact(self, datafile, data_dict):
         
        try:
            r_contact = pqc.analyse_contact_data(datafile)

        except Exception as err:
            r_contact = 'NaN'

        if '_P_' in datafile:
            par_dict = ({'CC_Edge [kOhm]' : r_contact })
            print("P") 
        elif '_N_' in datafile:
             par_dict = ({'CC_Strip [kOhm]' : r_contact })
             print("N")
        else:
            par_dict = ({ 'CC_poly [MOhm]' : r_contact})

        data_dict = append_dictionary(data_dict, par_dict, self.flute, 'contact')

        return data_dict




 def run(self):

      
      data_dict = {'Halfmoon': self.label} 

      for  key, f in self.functions.items():
 
        directory = tools.find_all_files_from_path(self.path, '{}'.format(key))
        for i in directory:
           print(i) 
           if 'Flute_4' in i:
              data_dict = f(i, data_dict)

      if os.path.isfile('/mnt/c/Users/Kostas/Desktop/{}.csv'.format(self.flute)):
           df = pd.DataFrame(data=data_dict, columns = data_dict.values(), index=[0])
      else:
           df = pd.DataFrame(data=data_dict, columns = data_dict.keys(), index=[0])
    
      df_to_csv(df, self.flute)






#####################################################################################################################


def parse_args():
        
        parser = argparse.ArgumentParser()
        parser.add_argument('path')
       #parser.add_argument('test')
        return parser.parse_args()

 


def main():
      
      
   args = parse_args()
   for subdir, dirs, files in os.walk(args.path):  
    for directory in dirs:
      
      #name= directory.path.split('/')[-2]
      label = '_'.join(directory.split('_')[1:])
      print(directory)
      flu = Flute1(directory, label) 
      flu.run()
      flu2 = Flute2(directory, label)
      #flu2.run()
      flu3 = Flute3(directory, label)
      #flu3.run()
      flu4 = Flute4(directory, label)
      #flu4.run()
          



if __name__=="__main__":
         main()

